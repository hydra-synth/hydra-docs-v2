[{"id":0,"href":"/hydra-docs-v2/docs/learning/video-synth-basics/src/","title":"Sources","section":"Video Synth Basics","content":" Source # noise # noise( scale = 10, offset = 0.1 )\nGenerate Perlin noise.\nvoronoi # voronoi( scale = 5, speed = 0.3, blending = 0.3 )\nGenerate voronoi shapes.\nosc # osc( frequency = 60, sync = 0.1, offset )\nshape # shape( sides = 3, radius = 0.3, smoothing = 0.01 )\ngradient # gradient( speed )\nsrc # src( tex ) Accepts a texture, such as external source (s0, s1, s2, s3) or an output (o0, o1, o2, o3)\nsolid # solid( r, g, b, a = 1 )\nprev # prev( )\nout # out( texture = all )\n"},{"id":1,"href":"/hydra-docs-v2/docs/quick-start/","title":"Quick start","section":"Docs","content":" hello world # start writing code in hydra! to get started:\nGo to https://hydra.ojack.xyz\nClose the top window by clicking the [x] in the top right.\nChange some numbers\nType \u0026ldquo;ctrl+shift+enter\u0026rdquo; to run the code (or use the triangle run button)\nhave fun! there is no \u0026ldquo;wrong\u0026rdquo; way to code in hydra :]\nNext steps # For more a more in-depth introductions see Getting Started: video synth basics. For an overview of available guides and resources, see learning.\n"},{"id":2,"href":"/hydra-docs-v2/docs/learning/video-synth-basics/coord/","title":"Geometry","section":"Video Synth Basics","content":" Geometry # rotate # rotate( angle = 10, speed )\nRotate texture.\nscale # scale( amount = 1.5, xMult = 1, yMult = 1, offsetX = 0.5, offsetY = 0.5 )\nScale texture.\npixelate # pixelate( pixelX = 20, pixelY = 20 )\nPixelate texture with pixelX segments and pixelY segments.\nrepeat # repeat( repeatX = 3, repeatY = 3, offsetX, offsetY )\nrepeatX # repeatX( reps = 3, offset )\nrepeatY # repeatY( reps = 3, offset )\nkaleid # kaleid( nSides = 4 )\nKaleidoscope effect with nSides repetition.\nscroll # scroll( scrollX = 0.5, scrollY = 0.5, speedX, speedY )\nscrollX # scrollX( scrollX = 0.5, speed )\nscrollY # scrollY( scrollY = 0.5, speed )\n"},{"id":3,"href":"/hydra-docs-v2/docs/learning/getting-started/","title":"Getting started","section":"learning","content":" Getting started with hydra # This document is an introduction to making live visuals using Hydra. It covers the basics of writing code in the browser to generate and mix live video sources. No coding or video experience is necessary!\nIf you just want to start in 60 seconds you can also check:\nGetting started short version This tutorial is meant to be used from within the hydra web editor. It is also interactive \u0026ndash; you can directly modify the code in each code block to see how it affects the visuals.\nGet to know the browser editor # To get started, open the the hydra web editor in a separate window. Close the top window by clicking the [x] in the top right.\nYou will see some colorful visuals in the background with text on top in the top left of the screen. The text is code that generates the visuals behind it.\nAt the right up corner you will find a toolbar with these buttons: run all code Runs all code on the page (same as typing *ctrl+shift+enter) upload to gallery upload a sketch to Hydra\u0026rsquo;s gallery and create a shorter URL clear all resets the environment and clears text from the editor show random sketch. Loads random sketch examples. Always it is a good way to learn Hydra by studying someone elses code. make random change dices modify values automatically. Try it with some of the sketch examples. show info window show overlay window with help text and links First line of code # Use the clear all button to erase the previous sketch.\nThen, type or paste the following in the editor:\nosc().out() Press the run button to run this code and update the visuals on the screen. You should see some scrolling stripes appear in the background.\nThis creates a visual oscillator. Try modifying the parameters of the oscillator by putting a number inside the parentheses of osc(), for example osc(10).out().\nRe-run the code by pressing the run button again, and seeing the visuals update. Try adding other values to control the oscillator\u0026rsquo;s frequency, sync, and color offset.\nTrick: you can also use the keyboard shortcut ‘ctrl + shift + enter’ to have the same effect as the run button.\nAdding transformations # We can add another transformation to the oscillator from above, by adding the function rotate() after the oscillator:\nAs you can see, you have first an input source osc() and things that come after (rotate() and out()) are connected with a dot ‘.’ In this sense, Hydra is inspired by modular synthesis. Instead of connecting cables you connect different kinds of javascript functions.\nsource Sandin Image Processor # You can continue adding transformations to this chain of functions. For example:\nRepeat:\nFor more available sources and transformations, see the interactive function reference. The logic is to start with a source (such as osc(), shape(), or noise()), and then add transformations to geometry and color (such as .rotate(), .kaleid(), .pixelate() ), and in the end always connect the chain of transformations to the output screen .out() .\nWhat is an error? # Sometimes, you will try to run a line of code, and nothing will happen. If you have an error you’ll notice text in red at the left-bottom on your screen. Something like ‘Unexpected token ‘.’ (in red) will appear. This doesn’t affect your code, but you won’t be able to continue coding until you fix the error. Usually it is a typing error or something related to the syntax.\nWhat is a comment? # // Hello I’m a comment line. I’m a text that won’t change your code. You can write notations, your name or even a poem here. Save your sketch on the internet # When you evaluate the entire code with the run button or with shift + ctrl + enter, Hydra automatically generates a URL that contains the last changes of your sketch. You can copy and paste the url from the URL bar to save it or share it with other people. You can also use the browser back and forward arrows to navigate to earlier versions of your sketch. Using the webcam # In addition to using sources from within hydra (such as osc() and shape()), you can use hydra to process external video sources such as a webcam. To initialize the webcam, run the following code:\ns0.initCam() This activates the webcam source inside a variable called s0, and you should see the light on your webcam light up. However, you will still not see the webcam image on the screen. In order to use the camera within a hydra sketch, you need to use it within the src() function.\nSimilar to adding transformations above, you can add transformations of color and geometry to the camera output, by adding functions to the chain:\nIf you have multiple webcams, you can access separate cameras by adding a number inside initCam, for example s0.initCam(1) or s0.initCam(2).\nMultiple outputs # By default, hydra contains four separate virtual outputs that can each render different visuals, and can be mixed with each other to create more complex visuals. The variables o0, o1, o2, and o3 correspond to the different outputs.\nTo see all four of the outputs at once, use the render() function. This will divide the screen into four, showing each output in a different section of the screen.\nUsing a different variable inside the .out() function renders the chain to a different output. For example, .out(o1) will render a function chain to graphics buffer o1.\nBy default, only output o0 is rendered to the screen, while the render() command divides the screen in four. Show a specific output on the screen by adding it inside of render(), for example render(o2) to show buffer o2.\nTrick: try to create different sketches and switch them in your live performance or even combine them.\nBlending multiple visual sources together # You can use blend functions to combine multiple visual sources. .blend() combines the colors from two sources to create a third source.\nTry adding transformations to the above sources (such as osc(10).rotate(0, 0.1).out(o1)) to see how it affects the combined image. You can also specify the amount of blending by adding a separate parameter to .blend(), for example .blend(o1, 0.9).\nThere are multiple blend modes in hydra, similar to blend modes you might find in a graphics program such as photoshop or gimp. See the function reference for more possibilities.\nModulation # While blend functions combine the colors from two visual sources, modulate functions use the colors from one source to affect the geometry of the second source. This creates a sort of warping or distorting effect. An analogy in the real world would be looking through a texture glass window. modulate() does not change color or luminosity but distorts one visual source using another visual source.\nUsing the same sources from above, we can use an oscillator to modulate or warp the camera image:\nYou can add a second parameter to the modulate() function to control the amount of warping: modulate(o1, 0.9). In this case, the red and green channels of the oscillator are being converted to x and y displacement of the camera image.\nAll geometry transformations have corresponding modulate functions that allow you to use one source to warp another source. For example, .modulateRotate() is similar to .rotate(), but it allows you to apply different amounts of rotation to different parts of the visual source. See the function reference for more examples.\nMore blending and modulating # In addition to using multiple outputs to combine visuals, you can also combine multiple sources within the same function chain, without rendering them to separate outputs.\nThis allows you to use many sources, blend modes, and modulation, all from within the same chain of functions.\nTrick: use ctrl + shift + f from the web editor to auto-format your code\nModulating with the camera # We have now covered all of the basic types of functions within hydra: source, geometry, color, blending, and modulation! See what you can come up with by mixing these together.\nHave fun! # by Flor de Fuego and Olivia Jack\n"},{"id":4,"href":"/hydra-docs-v2/docs/learning/web-editor/","title":"Using the web editor","section":"learning","content":" Web editor # basics of the browser editor at https://hydra.ojack.xyz\nkey commands # CTRL-Enter: run a line of code CTRL-Shift-Enter: run all code on screen ALT-Enter: run a block CTRL-Shift-H: hide or show code CTRL-Shift-F: format code using Prettier CTRL-Shift-S: Save screenshot and download as local file. The CTRL-Shift-G: Share to twitter (if available). Shares to @hydra_patterns toolbar # At the right up corner you will find a toolbar with these buttons: run all code Runs all code on the page (same as typing *ctrl+shift+enter) upload to gallery upload a sketch to Hydra\u0026rsquo;s gallery and create a shorter URL clear all resets the environment and clears text from the editor show random sketch. Loads random sketch examples. Always it is a good way to learn Hydra by studying someone elses code. make random change dices modify values automatically. Try it with some of the sketch examples. show info window show overlay window with help text and links share your sketch # When you evaluate the entire code with the run button or with shift + ctrl + enter, Hydra automatically generates a URL that contains the last changes of your sketch. You can copy and paste the url from the URL bar to save it or share it with other people. You can also use the browser back and forward arrows to navigate to earlier versions of your sketch. sharing with the code hidden # The showCode=false url flag makes it possible to share a sketch with the code hidden.\nFor example, the following sketch\nosc(10, 0.1, 1.2).modulateScale(noise(3)).out() is available at the URL https://hydra.ojack.xyz/?code=b3NjKDEwJTJDJTIwMC4xJTJDJTIwMS4yKS5tb2R1bGF0ZVNjYWxlKG5vaXNlKDMpKS5vdXQoKQ%3D%3D\nthis URL will correspond to the same sketch, but with the code and toolbar hidden: https://hydra.ojack.xyz/?code=b3NjKDEwJTJDJTIwMC4xJTJDJTIwMS4yKS5tb2R1bGF0ZVNjYWxlKG5vaXNlKDMpKS5vdXQoKQ%3D%3D\u0026showCode=false\npressing Ctrl+Shift+h will show the code again\nWhat is an error? # Sometimes, you will try to run a line of code, and nothing will happen. If you have an error you’ll notice text in red at the left-bottom on your screen. Something like ‘Unexpected token ‘.’ (in red) will appear. This doesn’t affect your code, but you won’t be able to continue coding until you fix the error. Usually it is a typing error or something related to the syntax.\nWhat is a comment? # // Hello I’m a comment line. I’m a text that won’t change your code. You can write notations, your name or even a poem here. "},{"id":5,"href":"/hydra-docs-v2/docs/learning/video-synth-basics/color/","title":"Color","section":"Video Synth Basics","content":" Color # posterize # posterize( bins = 3, gamma = 0.6 )\nshift # shift( r = 0.5, g, b, a )\ninvert # invert( amount = 1 )\nInvert color.\ncontrast # contrast( amount = 1.6 )\nLarger amount value makes higher contrast.\nbrightness # brightness( amount = 0.4 )\nluma # luma( threshold = 0.5, tolerance = 0.1 )\nthresh # thresh( threshold = 0.5, tolerance = 0.04 )\ncolor # color( r = 1, g = 1, b = 1, a = 1 )\nsaturate # saturate( amount = 2 )\nhue # hue( hue = 0.4 )\ncolorama # colorama( amount = 0.005 )\nShift HSV values.\nsum # sum( scale = 1 )\nr # r( scale = 1, offset )\ng # g( scale = 1, offset )\nb # b( scale = 1, offset )\na # a( scale = 1, offset )\n"},{"id":6,"href":"/hydra-docs-v2/docs/learning/video-synth-basics/","title":"Video Synth Basics","section":"learning","content":"Hydra is inspired by modular synthesis. Instead of connecting cables you connect different kinds of javascript functions.\nsource Sandin Image Processor # The logic is to start with a source (such as osc(), shape(), or noise()), and then add transformations to geometry and color (such as .rotate(), .kaleid(), .pixelate() ), and in the end always connect the chain of transformations to the output screen .out() .\nfor example, the following code renders an oscillator with parameters frequency, sync, and rgb offset:\nWe can add another transformation to the oscillator from above, by adding the function rotate() after the oscillator:\nPixelate the output of the above function:\n"},{"id":7,"href":"/hydra-docs-v2/docs/learning/","title":"learning","section":"Docs","content":" learning # getting started # step-by-step tutorial for starting to code with hydra\nweb editor # key commands, comments, saving sketches, loading extensions and external libraries, publishing to the gallery\nvideo synth basics # overview of hydra\u0026rsquo;s modular approach and main function types: sources, geometry, color, blending, and modulation.\nexternal sources # using webcams, images, videos, html canvas elements, and live streams inside a hydra sketch\nsequencing \u0026amp; interactivity # making dynamic and interactive sketches using arrays, custom functions, audio reactivity, mouse input, and MIDI controllers.\nextending hydra # using hydra with other javascript libraries such as P5.js, Tone.js, strudel. Writing custom GLSL functions, and using hydra in your own webpage.\nguides # deeper dives into hydra topics written by members of the community.\n"},{"id":8,"href":"/hydra-docs-v2/docs/reference/","title":"reference","section":"Docs","content":""},{"id":9,"href":"/hydra-docs-v2/posts/hello-world/","title":"Brand new hydra blog and documentation portal","section":"blog","content":"WIP portal for hydra video synth. This will be a home for news and updates regarding hydra, as well as a hub for community resources and documentaiton.\nFor the main hydra website, see the web editor.\nWe welcome contributions!\n"},{"id":10,"href":"/hydra-docs-v2/docs/learning/video-synth-basics/external-sources/","title":"External sources: webcam, video, canvas","section":"Video Synth Basics","content":" External Sources # Using the webcam # In addition to using sources from within hydra (such as osc() and shape()), you can use hydra to process external video sources such as a webcam. External sources in hydra are referenced using predefined objects s0, s1, s2, and s3. To initialize the webcam in s0, run the following code:\ns0.initCam() This activates the webcam source inside a variable called s0, and you should see the light on your webcam light up. However, you will still not see the webcam image on the screen. In order to use the camera within a hydra sketch, you need to use it within the src() function.\nSimilar to adding transformations above, you can add transformations of color and geometry to the camera output, by adding functions to the chain:\nIf you have multiple webcams, you can access separate cameras by adding a number inside initCam, for example s0.initCam(1) or s0.initCam(2).\nAvailable source functions # initCam() # You can use a webcam\u0026rsquo;s video as such:\ns0.initCam() s0.initCam(2) // if you have many cameras, you can select one specifically initImage() # Load an image into a source object:\n// load an image into a source object s0.initImage(\u0026#34;https://upload.wikimedia.org/wikipedia/commons/2/25/Hydra-Foto.jpg\u0026#34;) // show the image on the screen src(s0).out() When running Hydra in Atom, or any other local manner, you can load local files referring to them by URI:\ns0.initImage(\u0026#34;file:///home/user/Images/image.png\u0026#34;) Supported image formats # You can load .jpeg, .png, and .bmp as well as .gif and .webp (although animation won\u0026rsquo;t work).\ninitVideo() # The syntax for loading video is the same as for loading image, only changing the function to loadVideo:\ns0.initVideo(\u0026#34;https://media.giphy.com/media/AS9LIFttYzkc0/giphy.mp4\u0026#34;) src(s0).out() Supported video formats # You can load .mp4, .ogg and .webm videos.\nUseful HTML Video properties # You can access all of the HTML Video functions when a video is loaded to a Source via s0.src. Some useful properties are:\ns0.src.playbackRate = 2 // double the speed at which the video plays s0.src.currentTime = 10 // seek to the 10th second s0.src.loop = false // don\u0026#39;t loop the video initScreen() # You can capture your screen or specific windows or tabs to use as a video source:\ns0.initScreen() src(s0).out() init() # init() is a more generic function for loading any external source into hydra. This can be especially useful when you are using an HTML canvas element as an input, or loading an existing resource as a source into hydra. Valid input types are documented in the regl texture documentation.\nFor example, the following code creates a canvas element and draws text to it, and then uses that canvas as a source in hydra:\nuse the dynamic parameter to indicate whether the source will be updated, or remain the same.\ninitStream() # note: initStream() is currently broken in hydra editor due to server issues streaming between Hydra sessions\nHydra (the editor) also has built-in streaming. You can stream the output of your Hydra to someone else and vice-versa. This is done in a similar fashion to using images and videos, using external sources. But there are some extra steps for streaming:\nThe pb object # On your Hydra editor, you can find a pre-defined object called pb (as in patch-bay). This object basically represents the connection of your Hydra editor instance to all others hosted on the same server. When you want to share your stream to someone else you\u0026rsquo;ll have to give your Hydra session a name. Do this using the pb.setName() function and by passing in some string as the name. For example: pb.setName('myverycoolsession'). If you want someone else to stream to you, ask them to set a name as such and share it with you.\nYou can see online sessions using the function pb.list(), which will return an Array of names.\nStarting to stream # Streaming is as simple as initiating the source as a stream and passing the name of the session you want to stream. For example:\ns0.initStream(\u0026#39;myfriendsverycoolsession\u0026#39;) src(s0) .out() Extra parameters # Any external sources loaded into Hydra are using regl\u0026rsquo;s texture constructor in the background. There are many properties you can set when loading a texture and Hydra and regl handle the important ones for you. But to set any of these properties you can pass an object containing them to any of the init functions. For example:\ns0.initCam(0,{mag: \u0026#39;linear\u0026#39;}) mag \u0026amp; min are the most used, since using linear interpolation will resize textures in a smooth way. The default for both is nearest.\nCommon problems # CORS policy # If you try to load images (or videos) from some websites (most of them, really), sometimes nothing shows up on the screen. Opening the browser\u0026rsquo;s console might reveal a message similar to this one:\nAccess to image at \u0026#39;...\u0026#39; from origin \u0026#39;https://hydra.ojack.xyz\u0026#39; has been blocked by CORS policy: No \u0026#39;Access-Control-Allow-Origin\u0026#39; header is present on the requested resource. The CORS in CORS policy stands for \u0026lsquo;Cross-origin resource sharing\u0026rsquo;. This refers to the action of calling resources (such as images) from one website to another. For example, asking for an image hosted on other website from inside the Hydra editor. This error message is basically telling us \u0026ldquo;hey, the website you\u0026rsquo;re trying to ask for an image doesn\u0026rsquo;t allow other websites to use their resources, so i can\u0026rsquo;t let you have that picture\u0026rdquo;. In order to circumvent this error, you can try re-uploading the images you want to use to some image hosting service that allows cross-origin sharing such as imgur, where you can also load short videos. You can also try to use websites which you know will allow cross-origin resource sharing such as Wikimedia Commons, which is great for video.\nLoading video from YouTube, Vimeo, etc # Some users may be tempted to try and load some video they liked on YouTube, for example, and run something suchlike:\ns0.initVideo(\u0026#39;https://www.youtube.com/watch?v=dQw4w9WgXcQ\u0026#39;) // doesn\u0026#39;t work This will not work. The same goes for Vimeo and other video streaming services. When you use such an URL, it is not returning a video, it is returning the website where you can watch the video! The URL you pass to initVideo has to go directly to a video file. In other words, the URL should (usually) end in .mp4, .webm or .ogg. And, even if you did get a URL directly to the video with a tool such as youtube-dl, you\u0026rsquo;ll run into CORS problems.\nWorkaround # The most common workarounds are:\nRun Hydra locally (on Atom for example) and load local video files Have the video run on its own window and use initScreen to capture it "},{"id":11,"href":"/hydra-docs-v2/docs/learning/guides/textures/","title":"Hydra Book: Textures","section":"Guides","content":" Textures # by Naoto Hieda\nIn this chapter, we discuss textures or patterns, separately from colors or movements. Most of the snippets have low saturation in order to separate textures from other effects.\nOscillator # osc(freq,sync,offset) is one of the basic sources to create a texture. The first argument determines the frequency (i.e., how packed the stripes are), the second for the sync (i.e., the scroll speed), and the third for the offset, which adds color to the pattern. One cycle of an oscillator in the screen space can be achieved by osc(Math.PI * 2); thus the following example shows 10 cycles:\nFor simplicity, natural numbers are often used as freq or the first argument (e.g., osc(40,0)). The sync parameter is multiplied with time and freq; thus even if sync is unchanged, the larger the frequency, the faster the scroll speed (discussed in motions). offset cycles from 0 to PI*2, which shifts the color.\nBy adding thresh() or posterize(), the oscillator pattern becomes clear stripes. thresh(threshold) literally thresholds the grayscale value; if the pixel\u0026rsquo;s grayscale is brighter than threshold, returns white and else returns black (alpha is preserved). posterize(bins,gamma) thresholds with multiple steps, similar to histogram. pixelate() achieves a similar effect; however, the offset between the bumps of the oscillator and the pixelation bins can create artifacts.\n(render() displays four buffers; o0 on top left, o1 on bottom left, o2 on top right and o3 on bottom right)\nkaleid() with a large number creates circles,\n99 is a magic number; to save character counts (which is essential for live coding), 99 is big enough and only takes 2 characters. However, depending on the effect you want to create, you might need to set a higher number, such as 999, or 1e4.\nYou might have noticed that this sketch is stretched if the window is not square. scale(amount,x,y) can correct the scaling; it scales amount*x to x-axis and amount*y to y-axis. Therefore, scale(1,1,16/9) fits the sketch to 16:9 window, and in general,\nscale(1,1,()=\u0026gt;window.innerWidth/window.innerHeight) adapts the sketch to any size of the window. Notice ()=\u0026gt;, which is an arrow function. If a value is passed to a hydra function (e.g., scale(1,1,window.innerWidth/window.innerHeight)), it will be evaluated only once when ctrl+enter or ctrl+shift+enter is pressed. However, an arrow function is evaluated every frame; thus, it becomes responsive to the window size change. In the rest of the book, a square window is assumed for simplicity. Note that width and height global variables are set when the hydra canvas is initialized, and they will not change according to window resizing.\nkaleid with a small number creates a geometric shape (in the example, an oscillator is combined with kaleid and thresh).\nNoise # noise() is another basic function as a source. A texture is generated based on a variant of Perlin Noise.\nWe will look more into detail in the modulator and arithmetic sections.\nVoronoi # voronoi() is a source to generate a Voronoi diagram.\nShapes # shape(sides,radius,smoothing) generates a polygon with a number of sides set by sides. Nevertheless, it is more than just a polygon - radius changes the size of the shape, and most importantly, smoothing sets gradient of the shape; 1 for fuzzy borders and close to 0 for sharp edges (however, setting to 0 does not work in recent versions). For example, shape(2) is a thick line, which can be scaled to make a thin line.\nor simply,\nBy repeating shape(4) and overlapping them, it gives a grid-like pattern. For convenience, a parameter and a function are stored in JavaScript variables.\nSimilar to kaleid(), shape() with a large number of sides creates a circle. By tweaking the example above, it generates a Polka dot pattern.\nor almost equivalent with (the center of the image will be horizontally shifted)\nThis tiling technique can be used to create a RGB pixel filter. In this example, func is decomposed into R, G, and B channels and overlaid on top of each other.\nScaling # Scaling and difference can also create a periodic texture.\nThis technique can also be applied to a complex texture.\nThe effect can be enhanced by thresh and setting the third argument of voronoi to 0, to have sharp edges. However, a naive implementation will end up in a complete noise (notice that thresh(threshold, tolerance)\u0026rsquo;s tolerance has to be always bigger than 0).\nTo have a desired effect, apply a square mask (before trying the next example, apply solid().out(o0) to clear the buffer).\nThis example can be used together with rotation.\nOr, instead of scale, scrolling functions (scrollX and scrollY) can be used with a feedback loop.\n"},{"id":12,"href":"/hydra-docs-v2/docs/learning/sequencing-and-interactivity/","title":"Sequencing \u0026 interactivity","section":"learning","content":" Sequencing and Interactivity # If you\u0026rsquo;re coding in Hydra, you\u0026rsquo;re constantly trying many values to input to the sources and transforms, and it\u0026rsquo;s just a matter of time until you like how more than one looks, and you want to somehow switch between them. We\u0026rsquo;ll be referring to this idea of arguments whose value change over time as dynamic arguments. And there are two main ways to achieve this in Hydra: Arrays and functions.\nSequencing using Arrays # Sequence your inputs # When you send an Array as an input (indicated in javascript by []), Hydra will automatically switch and jump from each element from the Array to the next one. When there are no more elements, it wraps all the way back to the beginning. Let\u0026rsquo;s see it in action:\nchanging the speed # The arrays in hydra have a default bpm(beats-per-minute) of 30. You can change the speed of a specific array by adding .fast() at the end of the array. For example .fast(4) will make the above array run four times faster.\nThe speed of all arrays in a sketch can be changed using the bpm parameter of hydra synth.\nbpm = 60 smooth() interpolation # You can also interpolate between values instead of jumping from one to the other. That is, smoothly transition between values. For this you can use the .smooth method. It may take a Number argument (defaulted to 1) which controls the smoothness.\nCustom Functions # Each numerical parameter in hydra can be defined as a function rather than a static variable. For example,\nosc(function(){return 100 * Math.sin(time * 0.1)}).out() modifies the oscillator frequency as a function of time. (Time is a global variable that represents the milliseconds that have passed since loading the page).\nThe above example can be written more concisely using es6 syntax:\nosc(() =\u0026gt; 100 * Math.sin(time * 0.1)).out() Custom functions are especially useful for controlling hydra parameters using external inputs, such as the microphone, mouse, or midi control.\nby geikha\n"},{"id":13,"href":"/hydra-docs-v2/docs/learning/guides/how-to/","title":"How to","section":"Guides","content":" how-to # record hydra output Embed hydra in a website Route audio Use hydra offline in atom Publish an extension Contribute to documentation Contribute to hydra code repository Record a video "},{"id":14,"href":"/hydra-docs-v2/docs/learning/extending-hydra/contributing/","title":"Developing and contributing","section":"Extending Hydra","content":" Developing and Contributing # In this guide, you will learn how to \u0026ldquo;compile\u0026rdquo; hydra, to test your own version, and to contribute to the original repository. This guide is for those who are familar with JavaScript to edit the code base. Knowledge of command line and front-end tools is preferred but we try to guide you step by step.\nUnderstanding the structure # Hydra consists of mainly 4 repositories:\nhydra hydra-synth hydra-server l10n hydra, or hydra-editor, is the webpage that comes with the editor. If you want to make changes in, e.g., the behavior of the editor, this is the right repository. We will look into detail in developing editor.\nhydra-synth is the \u0026ldquo;engine\u0026rdquo; that processes your hydra code on the editor and produces GLSL (shader) code. We explain in detail in developing synth.\nhydra-server is a backend program for signaling and storing the gallery. Note that you don\u0026rsquo;t need this for testing the editor. We explain in detail in developing backend server.\nl10n is a collection of locale files, i.e., translations for the editor interface. If you want to contribute translations, please refer to this doc.\nAll contributors # Thank you to everyone who contributed to the project, not only contributing the code, but including reporting bugs, organizing events, and making tutorials, etc! We would like to acknowledge everyone who contributes to make hydra better. Please submit your information here.\n"},{"id":15,"href":"/hydra-docs-v2/docs/learning/extending-hydra/contributing/server/","title":"developing backend server","section":"Developing and contributing","content":" Developing backend server # (stub)\n"},{"id":16,"href":"/hydra-docs-v2/docs/learning/extending-hydra/contributing/editor/","title":"developing editor","section":"Developing and contributing","content":" Developing editor # To run locally, you must have nodejs and npm installed. Install node and npm from: https://nodejs.org/en/.\nFirst, clone the repository\ngit clone git@github.com:hydra-synth/hydra.git enter the directory of the hydra source code:\ncd hydra Current main branch # The current main branch uses browserify to bundle the script. While new features should be implemented in dev branch, if there is a hot fix needed in the current main branch, please follow this guide.\nOnce you have node and npm installed, you can install yarn globally by running the following from the command line:\nnpm install --global yarn install dependencies:\nyarn install bundle JavaScript with browserify:\nyarn build run server\nyarn serve go to http://localhost:8000 in the browser. Congratulations! You built hydra-editor on your computer!\nWhere do these commands come from? # Yarn commands are defined in package.json.\nDevelopment # Make your new branch\ngit checkout -b my-awesome-feature Edit the code. If you want to see changes in real time, you can use the watch script. After running yarn serve, open another terminal and run\nyarn watch Then every time you save code, it will automatically re-bundle the code.\nServing on your own server # (stub)\nCommit, push and pull request # (stub)\ndev branch # New features should be implemented in dev branch. After entering the directory, checkout the branch\ngit checkout -b dev origin/dev install dependencies:\nnpm install run dev environment\nnpm run dev Since we use vite in dev branch, we don\u0026rsquo;t need to bundle the code during development (vite takes care of bundling and serving while you code). When you want to publish the code, build the bundle:\nnpm run build Connecting to server from dev/ local editor environment # This repo only contains hydra editor frontend. You can connect to a backend server (https://github.com/hydra-synth/hydra-server) for signaling and gallery functionality. To do this, set up hydra-server from above. Then create a .env file in the root of the hydra directory. Add the url of your server as a line in the .env file as:\nVITE_SERVER_URL=http://localhost:8000 (replace http://localhost:8000 with the url of your server)\n"},{"id":17,"href":"/hydra-docs-v2/docs/learning/extending-hydra/contributing/synth/","title":"developing hydra-synth","section":"Developing and contributing","content":" Developing synth # Clone the repository\ngit@github.com:hydra-synth/hydra-synth.git enter the folder\ncd hydra-synth install the dependencies\nnpm install build\nnpm run build The bundled code is in dist/hydra-synth.js.\nTrying on the browser # This repository does not come with the editor. However, you can use the simple example dist/index.html. To do so, install http-server\nnpm install --global http-server and serve dist folder\nhttp-server dist go to http://localhost:8000 in the browser. You can either edit the hydra code in index.html to try hydra functions, or open the developer console and type hydra code (e.g., osc().out()) and it will update the canvas. The former is useful for testing more complex examples including non-global mode, and the later is useful for quick testing.\nFor testing the integration with hydra-editor (of if you want to host your own hydra version on your server), please follow editor guide to host your own editor. Then, edit package.json in hydra (not hydra-synth) to use the local version of hydra-synth (assuming you have hydra and hydra-synth folders in the same folder)\n\u0026quot;hydra-synth\u0026quot;: \u0026quot;file:../hydra-synth\u0026quot;, Then in hydra, update the package\nnpm update hydra-synth Now the editor is using your version of hydra-synth.\n"},{"id":18,"href":"/hydra-docs-v2/docs/learning/guides/","title":"Guides","section":"learning","content":" More Resources # Guides # Deeper dives into hydra topics written by members of the hydra community.\nJavascript for hydra users by geikha Generatively spawn patches by geikha Precise control of frames and timing by geikha Hydra Book: Textures by Naoto Hieda How to # Record hydra output Use hydra without showing the code Developing and Contributing # overview hydra-synth hydra-editor hydra-server "},{"id":19,"href":"/hydra-docs-v2/posts/hydra-meetup-8/","title":"hydra meetup #8 is today!","section":"blog","content":"Join us today at 15:00UTC for hydra meetup #8! There will be talks from hydra microgrant recipients Aida El-Oweidy, David Matunda, and Vagné L., as well as a chance for show and tell.\nSignups at: https://hydra-meetup-8.glitch.me\n"},{"id":20,"href":"/hydra-docs-v2/docs/learning/video-synth-basics/combine/","title":"Blend","section":"Video Synth Basics","content":" Multiple outputs # By default, hydra contains four separate virtual outputs that can each render different visuals, and can be mixed with each other to create more complex visuals. The variables o0, o1, o2, and o3 correspond to the different outputs.\nTo see all four of the outputs at once, use the render() function. This will divide the screen into four, showing each output in a different section of the screen.\nUsing a different variable inside the .out() function renders the chain to a different output. For example, .out(o1) will render a function chain to graphics buffer o1.\nBy default, only output o0 is rendered to the screen, while the render() command divides the screen in four. Show a specific output on the screen by adding it inside of render(), for example render(o2) to show buffer o2.\nTrick: try to create different sketches and switch them in your live performance or even combine them.\nBlending multiple visual sources together # You can use blend functions to combine multiple visual sources. .blend() combines the colors from two sources to create a third source.\nTry adding transformations to the above sources (such as osc(10).rotate(0, 0.1).out(o1)) to see how it affects the combined image. You can also specify the amount of blending by adding a separate parameter to .blend(), for example .blend(o1, 0.9).\nThere are multiple blend modes in hydra, similar to blend modes you might find in a graphics program such as photoshop or gimp. See the function reference for more possibilities.\nAvailable blend funcitons # add # add( texture, amount = 1 )\nAdd textures. The texture parameter can be any kind of source, for example a color, src, or shape.\nsub # sub( texture, amount = 1 )\nlayer # layer( texture )\nOverlay texture based on alpha value. The texture parameter can be any kind of source, for example a color, src, or shape.\nblend # blend( texture, amount = 0.5 )\nBlend textures. The texture parameter can be any kind of source, for example a color, src, or shape.\nmult # mult( texture, amount = 1 )\nMultiply images and blend with the texture by amount. The texture parameter can be any kind of source, for example a color, src, or shape.\ndiff # diff( texture )\nReturn difference of textures. The texture parameter can be any kind of source, for example a color, src, or shape.\nmask # mask( texture )\n"},{"id":21,"href":"/hydra-docs-v2/docs/learning/video-synth-basics/combinecoord/","title":"Modulate","section":"Video Synth Basics","content":" Modulation # While blend functions combine the colors from two visual sources, modulate functions use the colors from one source to affect the geometry of the second source. This creates a sort of warping or distorting effect. An analogy in the real world would be looking through a texture glass window. modulate() does not change color or luminosity but distorts one visual source using another visual source.\nUsing the same sources from above, we can use an oscillator to modulate or warp the camera image:\nYou can add a second parameter to the modulate() function to control the amount of warping: modulate(o1, 0.9). In this case, the red and green channels of the oscillator are being converted to x and y displacement of the camera image.\nAll geometry transformations have corresponding modulate functions that allow you to use one source to warp another source. For example, .modulateRotate() is similar to .rotate(), but it allows you to apply different amounts of rotation to different parts of the visual source. See the function reference for more examples.\nMore blending and modulating # In addition to using multiple outputs to combine visuals, you can also combine multiple sources within the same function chain, without rendering them to separate outputs.\nThis allows you to use many sources, blend modes, and modulation, all from within the same chain of functions.\nTrick: use ctrl + shift + f from the web editor to auto-format your code\nModulating with the camera # Available modulate functions # modulateRepeat # modulateRepeat( texture, repeatX = 3, repeatY = 3, offsetX = 0.5, offsetY = 0.5 )\nThe texture parameter can be any kind of source, for example a color, src, or shape.\nmodulateRepeatX # modulateRepeatX( texture, reps = 3, offset = 0.5 )\nThe texture parameter can be any kind of source, for example a color, src, or shape.\nmodulateRepeatY # modulateRepeatY( texture, reps = 3, offset = 0.5 )\nThe texture parameter can be any kind of source, for example a color, src, or shape.\nmodulateKaleid # modulateKaleid( texture, nSides = 4 )\nThe texture parameter can be any kind of source, for example a color, src, or shape. See also: kaleid.\nmodulateScrollX # modulateScrollX( texture, scrollX = 0.5, speed )\nThe texture parameter can be any kind of source, for example a color, src, or shape. See also: scrollX\nmodulateScrollY # modulateScrollY( texture, scrollY = 0.5, speed )\nThe texture parameter can be any kind of source, for example a color, src, or shape. See also: scrollY\nmodulate # modulate( texture, amount = 0.1 )\nModulate texture. More about modulation at: https://lumen-app.com/guide/modulation/ The texture parameter can be any kind of source, for example a color, src, or shape.\nmodulateScale # modulateScale( texture, multiple = 1, offset = 1 )\nThe texture parameter can be any kind of source, for example a color, src, or shape. See also: scale.\nmodulatePixelate # modulatePixelate( texture, multiple = 10, offset = 3 )\nThe texture parameter can be any kind of source, for example a color, src, or shape. See also: pixelate\nmodulateRotate # modulateRotate( texture, multiple = 1, offset )\nThe texture parameter can be any kind of source, for example a color, src, or shape. See also: rotate\nmodulateHue # modulateHue( texture, amount = 1 )\nChanges coordinates based on hue of second input. Based on: https://www.shadertoy.com/view/XtcSWM The texture parameter can be any kind of source, for example a color, src, or shape.\n"},{"id":22,"href":"/hydra-docs-v2/docs/learning/video-synth-basics/settings/","title":"Synth Settings","section":"Video Synth Basics","content":" Synth Settings # Functions and settings that affect overall hydra behavor and rendering.\nrender # render( texture = all )\n// default osc(30,0.1,1.5).out(o0) noise().out(o1) solid(1).out(o2) gradient().out(o3) render() update # update( )\nsetResolution # setResolution( width, height )\n// make the canvas small (100 pixel x 100 pixel) setResolution(100,100) osc().out(o0) hush # hush( )\n// clear the buffers osc().out(o0) hush() setFunction # setFunction( options )\nspeed # speed = 1\nbpm # bpm = 30\nwidth # width\nheight # height\ntime # time\nmouse # mouse = { x, y }\n"},{"id":23,"href":"/hydra-docs-v2/contributing_code/","title":"Contributing Code","section":"hydra video synth: documentation portal","content":" Contributing Code # Running locally # To run locally, you must have nodejs, yarn and npm installed. Install node and npm from: https://nodejs.org/en/\nInstall yarn from the command line\nnpm install --global yarn open terminal and enter directory\ncd hydra install dependencies:\nyarn install run server\nyarn serve go to https://localhost:8000 in the browser\nTo develop # Edit frontend/public/index.html to load \u0026lsquo;bundle.js\u0026rsquo; rather than \u0026lsquo;bundle.min.js\u0026rsquo;\nRun development server\nyarn dev "},{"id":24,"href":"/hydra-docs-v2/contributing_translation/","title":"Contributing Translation","section":"hydra video synth: documentation portal","content":" Contributing Translation # Everyone is welcome to contribute translations - such as improvement of the existing pages, writing original contents and adding a new language support :)\nType of Documents # hydra-documents: Guides and this document, which can be found at https://hydra.ojack.xyz/docs/ hydra-functions: the API reference, which can be found at https://hydra.ojack.xyz/api/ hydra editor: the main editor https://hydra.ojack.xyz/ hydra-documents # hydra-documents are accessible at https://hydra.ojack.xyz/docs/ and the contents are hosted on GitHub. In short, if you edit files on GitHub, they will be updated on the website (the first link).\nHere we assume you are familiar with Git. If you are not familiar with it and want to make suggestions, don\u0026rsquo;t worry - for small changes like typo, feel free to use \u0026ldquo;Edit this file\u0026rdquo; button on GitHub or open an issue so someone can make the edit!\nFork and clone the repository https://github.com/hydra-synth/hydra-docs If the language you contribute is not supported at all, create a folder with language code (e.g., /ja for Japanese). At the moment we don\u0026rsquo;t use region code (e.g., fr-ca for French Canadian) - but feel free to suggest if that is necessary! For translating articles existing in English (e.g., getting_started.md), create a file under the language folder with the same name (e.g., /ja/getting_started.md). For original contents, feel free to name it as you like :) Translate the document!\nTip 1: files are written in markdown format. It\u0026rsquo;s important to keep the same structure as the English one (like ## tag for headings). If you couldn\u0026rsquo;t finish translating the whole file, leave remaining headings and texts in English so someone else or you can continue editing later.\nTip 2: code blocks should have javascript tag as seen in the files in English so that they will be rendered with an embedded editor. Feel free to add your name and contact to the translated file :) Add a hyperlink to the file to /_sidebar.md - the translated contents go under a bullet point of the language (e.g., Japanese | 日本語). Otherwise, your contributed file won\u0026rsquo;t appear on the sidebar :( Make a git commit and push it to your GitHub repository! Create a pull request. We try our best to merge the edits as soon as possible! hydra-functions # hydra-functions are accessible at https://hydra.ojack.xyz/api/ and the contents are hosted on GitHub. Currently, you need to manually build the javascript bundle.\nstub:\nClone and fork the repository npm install edit here https://github.com/hydra-synth/hydra-functions/blob/main/locales.js for examples, edit here https://github.com/hydra-synth/hydra-functions/blob/main/examples.js npm run build commit, push, PR hydra editor # currently not supported\n"},{"id":25,"href":"/hydra-docs-v2/docs/learning/extending-hydra/hydra-in-a-webpage/","title":"Hydra in a Webpage","section":"Extending Hydra","content":" Hydra-Synth # In addition to using hydra within the hydra web editor, it is also possible to use the hydra video-synth engine as a library within your own javascript projects.\nhydra-synth is a javascript library containing the main logic of hydra packaged as a javascript module.\nTo include in a webpage (bundled version): # Include the bundled version of hydra-synth in your html file:\n\u0026lt;script src=\u0026#34;https://unpkg.com/hydra-synth\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // create a new hydra-synth instance var hydra = new Hydra({ detectAudio: false }) osc(4, 0.1, 1.2).out() \u0026lt;/script\u0026gt; You can see and remix a live example here: https://glitch.com/edit/#!/hydra-webpage\nTo use as a module: # Download the module:\nnpm install --save hydra-synth Include in your app:\nimport Hydra from \u0026#39;hydra-synth\u0026#39; const hydra = new Hydra({ detectAudio: false }) osc(4, 0.1, 1.2).out() To use using cjs/require syntax: # const Hydra = require(\u0026#39;hydra-synth\u0026#39;) The rest of this README is about configuring hydra-synth. For broader hydra documentation and usage, see learning hydra\nAPI: # const hydra = new Hydra([opts]) create a new hydra instance\nIf opts is specified, the default options (shown below) will be overridden.\n{ canvas: null, // canvas element to render to. If none is supplied, a canvas will be created and appended to the screen width: // defaults to canvas width when included, 1280 if not height: // defaults to canvas height when included, 720 if not autoLoop: true, // if true, will automatically loop using requestAnimationFrame.If set to false, you must implement your own loop function using the tick() method (below) makeGlobal: true, // if false, will not pollute global namespace (note: there are currently bugs with this) detectAudio: true, // recommend setting this to false to avoid asking for microphone numSources: 4, // number of source buffers to create initially numOutputs: 4, // number of output buffers to use. Note: untested with numbers other than 4. render() method might behave unpredictably extendTransforms: [] // An array of transforms to be added to the synth, or an object representing a single transform precision: null // force precision of shaders, can be \u0026#39;highp\u0026#39;, \u0026#39;mediump\u0026#39;, or \u0026#39;lowp\u0026#39; (recommended for ios). When no precision is specified, will use highp for ios, and mediump for everything else. pb = null, // instance of rtc-patch-bay to use for streaming } Custom render loop # You can use your own render loop for triggering hydra updates, instead of the automatic looping. To use, set autoLoop to false, and call\nhydra.tick(dt) where dt is the time elapsed in milliseconds since the last update\nTo develop: # npm run dev Sets up an example using hydra-synth that is automatically updated when source files are updated. It is possible to write test code by editing /example/index.js or by writing hydra code into the developer console.\nNon-global mode # If makeGlobal is set to false, buffers and functions can be accessed via the synth property of the hydra instance.\nconst h = new Hydra({ makeGlobal: false, detectAudio: false }).synth h.osc().rotate().out() In non-global mode, it is important to start all hydra functions, buffers, and variables by referencing the instance of hydra synth you are currently using.e.g.\nconst h = new Hydra({ makeGlobal: false, detectAudio: false }).synth h.osc().diff(h.shape()).out() h.gradient().out(h.o1) h.render() This also makes it possible to use more than one hydra canvas at once:\nconst h = new Hydra({ makeGlobal: false, detectAudio: false }).synth h.osc().diff(h.shape()).out() h.gradient().out(h.o1) h.render() const h2 = new Hydra({ makeGlobal: false, detectAudio: false }).synth h2.shape(4).diff(h2.osc(2, 0.1, 1.2)).out() See https://glitch.com/edit/#!/multi-hydra for a working example of multiple hydra canvases, created by Naoto Hieda.\nIf you would like to keep the same syntax as hydra in non-global mode, consider destructuring the object further:\nconst { src, osc, gradient, shape, voronoi, noise, s0, s1, s2, s3, o0, o1, o2, o3, render } = hydra shape(4).diff(osc(2, 0.1, 1.2)).out() hydra-ts is a fork of hydra-synth in Typescript maintained by @folz.\nKnown issues / troubleshooting # Vite # When using hydra with Vite, you might see the error\nAutoplay on iOS # from issue https://github.com/hydra-synth/hydra-synth/issues/137\nIt seems on mobile safari, videos won\u0026rsquo;t autoplay because of several reasons:\nyou need playsinline attribute (which can be added programmatically) https://stackoverflow.com/questions/43570460/html5-video-autoplay-on-iphone If the \u0026lt;video\u0026gt; element is not rendered on screen, the video does not update. As a workaround, you can make a small render of the video in a corner and this seems to work \u0026lt;video style=\u0026#34;position:static;top:1px;width:1px;height:1px\u0026#34; id=\u0026#34;vid\u0026#34; autoplay loop muted playsinline crossorigin\u0026gt; \u0026lt;source src=\u0026#34;https://cdn.glitch.global/8df667c3-e544-4cbb-8c16-f604238e8d2e/paper.mov?v=1682418858521\u0026#34;\u0026gt; \u0026lt;/video\u0026gt; let v = document.getElementById(\u0026#34;vid\u0026#34;) v.addEventListener(\u0026#39;loadeddata\u0026#39;, () =\u0026gt; { s0.init({src: v}) }) Here is a live example: https://glitch.com/edit/#!/hydra-video-autoplay-ios\n"},{"id":26,"href":"/hydra-docs-v2/docs/learning/guides/frames-and-timing/","title":"Frames and Timing","section":"Guides","content":" frames and timing # by geikha\nUsing the update function # There\u0026rsquo;s a function in the Hydra API called update. This function runs at the beginning of every frame render right before the values for time and a.fft are calculated. If you are familiar with Processing or p5, you can think of update as Hydra\u0026rsquo;s equivalent to the draw function. Using update can be very useful for creating generative visuals (generative in the sense of controlling visual elements with values that evolve through time either randomly or following certain rules). It can also be used to have a finer and/or connected control over parameters when compared to using simple arrow functions as arguments. It is also worth noting that the function receives a dt argument, which contains the delta time elapsed between the rendering of the previous frame and the current one. You may or may not want to use this to control your visuals (most of the examples don\u0026rsquo;t use it, actually).\nExamples # Using update and time to have complex control of parameters through time # The structure time % every \u0026lt; duration is super useful to make stuff happen every certain amount of seconds, for a given duration (also in seconds). time % wavelength / wavelength can be interpreted as a sawtooth wave with a given wavelength. This would generate an ascending sawtooth going from 0 to 1 in the amount of time specified by whe wavelength. For a descending one you can write something like 1-(time % wavelength / wavelength). If you want values from 0 to wavelength just remove the division.\nAdding a frame counter to make frame-specific actions # Having something appear for only one frame can be super useful in many feedback-based sketches:\nRandomly evolving values through time (Random walker) # update vs Arrow functions # Every function that you use as an argument is evaluated right before the current frame is about to be rendered. Which is the same thing that happens with the update function! This means, unless we use dt, everything we can do on update we can technically do on argument functions. It\u0026rsquo;s up for us to decide when one\u0026rsquo;s better than the other. If we are controlling many interconnected variables and procedures, most probably, an arrow function or a named function won\u0026rsquo;t be that nice to use. It\u0026rsquo;ll be confusing as to why a function which is supposed to represent a simple dynamic argument is doing so much stuff inside of itself. Maybe we could separate the different behaviors into many arrow functions. But if these functions were to feed from each other, this will yet again get confusing quite rapidly. Even then, there are many scenarios where an arrow function can do the same work as the update function with less code. For example, here\u0026rsquo;s a patch where a circle chases your mouse:\n"},{"id":27,"href":"/hydra-docs-v2/docs/learning/guides/hydra-garden/","title":"Hydra Garden","section":"Guides","content":""},{"id":28,"href":"/hydra-docs-v2/docs/learning/sequencing-and-interactivity/arrays/","title":"Arrays","section":"Sequencing \u0026 interactivity","content":" Arrays # Sequence your inputs # When you send an Array as an input, Hydra will automatically switch and jump from each element from the Array to the next one. When there are no more elements, it wraps all the way back to the beginning. Let\u0026rsquo;s see it in action:\nAs you can see, the fact that both these Arrays have a different amount of values doesn\u0026rsquo;t matter, Hydra will take values from each element of any Array for the same amount of time by default.\nThe Arrays can be passed in any way, you may have a variable that stores an Array and use its name within your sketches (not recommended in some scenarios, more info below), you may create a function that returns Arrays and use that to automatically generate discrete sequences of values:\nChanging the global bpm for Arrays # To change how rapidly Hydra switches from element to element of all Arrays, you can change the bpm variable (meaning beats per minute) to any value you desire:\nThe default value for bpm is 30.\nWhen livecoding visuals at the same time that music is playing, it can be useful to have a tapping metronome opened to keep track of the BPM being played and set this variable as such.\nChanging the speed of a specific Array # Hydra adds a couple of methods to all Arrays to be used inside Hydra. .fast will control the speed at which Hydra takes elements from the Array. It receives a Number as argument, by which the global speed will be multiplied. So calling .fast(1) on an Array is the same as nothing. Higher values will generate faster switching, while lower than 1 values will be slower.\nOffsetting the timing of an Array # Another one of the methods Hydra adds to Arrays, allows you to offset the timing at which Hydra will switch from one element of the Array to the next one. The method .offset takes a Number from 0 to 1.\nFitting the values of an Array within a range # Sometimes you have an Array whose values aren\u0026rsquo;t very useful when used as input for a some Hydra function. Hydra adds a .fit method to Arrays which takes a minimum and a maximum to which fit the values into:\nInterpolating between values # You can also interpolate between values instead of jumping from one to the other. That is, smoothly transition between values. For this you can use the .smooth method. It may take a Number argument (defaulted to 1) which controls the smoothness.\nTry smoothing some of the above examples and see what happens!\nEasing functions # The default interpolation used by Hydra on an Array that called .smooth is linear interpolation. You can select a different easing function as follows:\nThe following are the available easing functions:\nlinear: no easing, no acceleration easeInQuad: accelerating from zero velocity easeOutQuad: decelerating to zero velocity easeInOutQuad: acceleration until halfway, then deceleration easeInCubic easeOutCubic easeInOutCubic easeInQuart easeOutQuart easeInOutQuart easeInQuint easeOutQuint easeInOutQuint sin: sinusoidal shape Note on storing Arrays on variables / functions # Storing an Array in a variable can lead to some trouble as soon as you apply some of the just-mentioned functions to it. Since Arrays are Objects, each time you call your variable, you\u0026rsquo;ll be calling the same Object. If you apply some speed via .fast or smoothness via .smooth somewhere in your patch, and then use the same variable, all the following uses of the Array will also have these effects applied to them. For example\nNote on Arrays and textures # Note that the following will not work:\nsolid(1,.5,0) .diff([osc(),noise()]) .out() Hydra can\u0026rsquo;t handle Arrays of textures. You can work around it in some ways:\nUnfortunately, if you want to use many textures this solution doesn\u0026rsquo;t really apply.\nUsers of Hydra have come up with some experimental solutions which might come in handy in some scenarios, but they come with some drawbacks:\n// blending method, heavy GPU load. // every element from the array will be rendered even if not shown. // allows for blending between elements. select = function(arr,l=0){ const clamp = (num, min, max) =\u0026gt; Math.min(Math.max(num, min), max) const blending = (l,i)=\u0026gt; (clamp(l-(i-1),0,1)) const isFunction = (typeof l === \u0026#39;function\u0026#39;) return arr.reduce((prev,curr,i)=\u0026gt; prev.blend(curr, isFunction ? ()=\u0026gt;blending(l(),i) : blending(l,i)) ) } textures = [noise(), osc(), voronoi(), gradient()] select(textures,()=\u0026gt;Math.floor(mouse.x/innerWidth*4)) .out() // re-compiling method, heavy CPU load. // it reserves an output for the switching. // can\u0026#39;t blend between elements. // each time an element switches the shader must be recompiled osc(20) .rotate() .modulate(o3,.2) .out() textures = [noise(), osc(), voronoi(), shape()] index = 0 tex = textures[index] update = (dt)=\u0026gt; { if(time % (60 / bpm) * 1000 \u0026lt; dt){ index++; index %= textures.length; tex = textures[index] tex.out(o3) } } by geikha\n"},{"id":29,"href":"/hydra-docs-v2/docs/learning/sequencing-and-interactivity/audio/","title":"Audio","section":"Sequencing \u0026 interactivity","content":" Audio reactivity # FFT functionality is available via an audio object accessed via \u0026ldquo;a\u0026rdquo;. The editor uses https://github.com/meyda/meyda for audio analysis. To show the fft bins,\na.show() Set number of fft bins:\na.setBins(6) Access the value of the leftmost (lowest frequency) bin:\na.fft[0] Use the value to control a variable:\nosc(10, 0, () =\u0026gt; a.fft[0]*4) .out() It is possible to calibrate the responsiveness by changing the minimum and maximum value detected. (Represented by blur lines over the fft). To set minimum value detected:\na.setCutoff(4) Setting the scale changes the range that is detected.\na.setScale(2) The fft[] will return a value between 0 and 1, where 0 represents the cutoff and 1 corresponds to the maximum.\nYou can set smoothing between audio level readings (values between 0 and 1). 0 corresponds to no smoothing (more jumpy, faster reaction time), while 1 means that the value will never change.\na.setSmooth(0.8) To hide the audio waveform:\na.hide() a.setBins(5) // amount of bins (bands) to separate the audio spectrum noise(2) .modulate(o0,()=\u0026gt;a.fft[1]*.5) // listening to the 2nd band .out() a.setSmooth(.8) // audio reactivity smoothness from 0 to 1, uses linear interpolation a.setScale(8) // loudness upper limit (maps to 0) a.setCutoff(0.1) // loudness from which to start listening to (maps to 0) a.show() // show what hydra\u0026#39;s listening to // a.hide() render(o0) "},{"id":30,"href":"/hydra-docs-v2/docs/learning/sequencing-and-interactivity/midi/","title":"Midi","section":"Sequencing \u0026 interactivity","content":" MIDI # Hydra can be used with Web MIDI for an extra layer of control to your visuals.\nExample script: browser console # At this time this requires some running of code on the browser console (Press F12 in Chrome to access). This page only considers MIDI Continuous Controllers (CC) but other types of data may be accessible.\nThis is a generic script that doesn\u0026rsquo;t care what Midi Channel you\u0026rsquo;re broadcasting on and maps a normalized value 0.0-1.0 into an array named cc.\nThis portion should be ran in the console \u0026amp; will register Web MIDI \u0026amp; map the incoming CC data to a set of parameters. For simplicity, these parameters are named to match the CC number. The CC values are normally in a range from 0-127, but we\u0026rsquo;ve also normalized them to be in a range of 0.0-1.0.\n// register WebMIDI navigator.requestMIDIAccess() .then(onMIDISuccess, onMIDIFailure); function onMIDISuccess(midiAccess) { console.log(midiAccess); var inputs = midiAccess.inputs; var outputs = midiAccess.outputs; for (var input of midiAccess.inputs.values()){ input.onmidimessage = getMIDIMessage; } } function onMIDIFailure() { console.log(\u0026#39;Could not access your MIDI devices.\u0026#39;); } //create an array to hold our cc values and init to a normalized value var cc=Array(128).fill(0.5) getMIDIMessage = function(midiMessage) { var arr = midiMessage.data var index = arr[1] //console.log(\u0026#39;Midi received on cc#\u0026#39; + index + \u0026#39; value:\u0026#39; + arr[2]) // uncomment to monitor incoming Midi var val = (arr[2]+1)/128.0 // normalize CC values to 0.0 - 1.0 cc[index]=val } Hydra script # Now that these controls have been assigned to the cc[] array, we can start using them in Hydra. As we\u0026rsquo;ve normalized the values 0-1 we can use as-is with most functions or quickly remap them with various math.\n// example midi mappings - Korg NanoKontrol2 CCs // color controls with first three knobs noise(4).color( ()=\u0026gt;cc[16], ()=\u0026gt;cc[17], ()=\u0026gt;cc[18] ).out() // rotate \u0026amp; scale with first two faders osc(10,0.2,0.5).rotate( ()=\u0026gt;(cc[0]*6.28)-3.14 ).scale( ()=\u0026gt;(cc[1]) ).out() MIDI extension # "},{"id":31,"href":"/hydra-docs-v2/docs/learning/sequencing-and-interactivity/mouse/","title":"Mouse","section":"Sequencing \u0026 interactivity","content":" Mouse interactivity # You can have your visuals react to the position of your mouse (or finger, in touch devices). Hydra has an object called mouse which stores and keeps track of the position of your mouse on the webpage.\nmouse.x \u0026amp; mouse.y # | You can refer to the pixel position of your mouse by calling mouse.x and mouse.y, each one corresponding to the horizontal and vertical coordinates respectively. When we say \u0026lsquo;pixel position\u0026rsquo;, this means that the values you\u0026rsquo;ll find stored in both x and y are represented in pixels. So for mouse.x, this means the amount of pixels from the left edge of your window to the position of your mouse. For mouse.y, this means the amount of pixels between the top end of your screen and the position of your mouse.\nMany times it will be most useful to use values relative to the size of the screen. And also to have values that exist between ranges more reasonable to the hydra functions you\u0026rsquo;re using. For example [-0.5; 0.5] for scrollX and scrollY, [0; 2pi] for rotation, or [0; 1] for general purposes.\nNote # All of the examples using mouse position to move stuff on the canvas won\u0026rsquo;t work well here, since the canvas doesn\u0026rsquo;t occupy the full size of the screen as in the editor. Take this into account when we use mouse, that the positions are relative to the full webpage and not the canvas. This also means that as you scroll down this guide the y value will get higher and higher.\nControl anything with your mouse # On Hydra, most values used are pretty small. So it will be way more useful to have the position of the mouse as values from 0 and 1:\nGetting values from 0 to 1 # You can simply multiply by 2*Math.PI to change the range to [0; 2pi]\nMake something follow your mouse # On Hydra, things are placed between 0.5 and -0.5 (left to right, top to bottom). In order for anything to follow your mouse, you\u0026rsquo;ll need to get the position of your mouse between that range:\nGetting values from 0 to ±0.5 from the center # Remember you can name these functions however you prefer.\nThe time variable seen there is a variable pre-declared by Hydra, that stores how much time passed since Hydra started in seconds.\nFunctions used in Hydra don\u0026rsquo;t need to be arrow functions, any no-argument function will do! Make sure your function is returning a Number to avoid errors.\nThe time variable # When you use functions that can take numerical arguments, time will allow you to have their values evolve through\u0026hellip; time. If you multiply time by some value it\u0026rsquo;s as if time goes faster, while dividing while act as making time go slower. For example Math.sin(time*4) will go 4 times faster than Math.sin(time).\nThose users more familiar with mathematics might see this as:\ny(t) = t : ()=\u0026gt;time y(t) = A sin(f t + ph) : ()=\u0026gt;amplitude*Math.sin(freq*time + phase) We recommend getting familiar with some of the methods in the JS built-in Math object. Learn more about it here\nby geikha\n"},{"id":32,"href":"/hydra-docs-v2/docs/community/","title":"community","section":"Docs","content":" community projects, libraries, and resources # "},{"id":33,"href":"/hydra-docs-v2/docs/learning/extending-hydra/glsl/","title":"Custom GLSL","section":"Extending Hydra","content":" GLSL Guide # Using custom GLSL functions # Hydra is built using GLSL (a language for generating a program, or shader, that runs directly on the graphics card using WebGl). Each javascript function in hydra corresponds directly to a snippet of shader code. Hydra has a unique way of adding custom source and transform functions which we will explain here.\nsetFunction # The Hydra API includes a function called setFunction which receives a specific type of JavaScript object. This object will have the properties name, type, inputs and glsl.\nname is a String with the name for the function type is one of the available types of functions (\u0026lsquo;src\u0026rsquo;, \u0026lsquo;color\u0026rsquo;, \u0026lsquo;coord\u0026rsquo;, \u0026lsquo;combine\u0026rsquo;, \u0026lsquo;combineCoord\u0026rsquo;) inputs is an Array of objects each with it\u0026rsquo;s own name, type and default properties. They represent the arguments of the GLSL function. glsl is a String with the glsl code. Example # setFunction({ name: \u0026#39;myOsc\u0026#39;, type: \u0026#39;src\u0026#39;, inputs: [ { name: \u0026#39;freq\u0026#39;, type: \u0026#39;float\u0026#39;, default: 20 } ], glsl: ` return vec4(sin((_st.x+time)*freq*vec3(0.1)),1.0); ` }) Types of GLSL functions and their arguments # src # A function with a specified type of src is one that generates visuals by its own. Just like osc or noise. They all have a vec2 argument called _st for the coordinate. And you can add any custom inputs as shown above. You must return a vec4.\ncolor # A color function receives a vec4 called _c0 that represents the color being affected by the transform. As any function you may add any extra inputs. You must return another vec4.\ncoord # A coord function receives a vec2 called _st that represents the coordinate plane. You must return another vec2.\ncombine # The functions of type combine receive 2 vec4 arguments, _c0 and _c1. The first one represents the texture being affected and the latter represents the texture being blended into the former. For example, when you use osc().mult(noise()), inside the definition of the function, _c0 represents the osc() and _c1 represents the noise() colors. You can think combine functions as blending modes. And as custom function you may add extra inputs as needed. You must return a vec4.\ncombineCoord # combineCoord functions change the position of colors in the texture being affected given the colors of another texture. Think about the many modulate functions for example, since they are precisely this type. They receive a vec2 _st and a vec4 _c0. You must return a vec2.\nBuilt in functions you can use # The following functions are pre-defined for every Hydra generated shader, and in the same way that some built-in functions use them, you may too:\n_luminance # float _luminance(vec3 rgb){ const vec3 W = vec3(0.2125, 0.7154, 0.0721); return dot(rgb, W); } Returns the luminance of a given rgb color.\n_rgb2Hsv # vec3 _rgbToHsv(vec3 c){ vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0); vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g)); vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r)); float d = q.x - min(q.w, q.y); float e = 1.0e-10; return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x); } Transforms a color from the rgb to the hsv colorspace.\n_hsv2Rgb # vec3 _hsvToRgb(vec3 c){ vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); } Transforms a color from the hsv colorspace back to rgb.\nNote # As of now there is no way to define \u0026ldquo;global\u0026rdquo; functions such as these ones just mentioned. But expect it soon!\nExamples # Chroma Key # This example modifies color to replace green background with transparency (i.e., chroma keying). The GLSL code is ported from Inigo Quilez\u0026rsquo;s example.\nsetFunction({ name: \u0026#39;chroma\u0026#39;, type: \u0026#39;color\u0026#39;, inputs: [ ], glsl: ` float maxrb = max( _c0.r, _c0.b ); float k = clamp( (_c0.g-maxrb)*5.0, 0.0, 1.0 ); float dg = _c0.g; _c0.g = min( _c0.g, maxrb*0.8 ); _c0 += vec4(dg - _c0.g); return vec4(_c0.rgb, 1.0 - k); `}) // s0.initCam() // src(s0).out(o0) solid(0,1,0).layer(shape(5,0.3,0.3).luma()).out(o0) osc(30, 0, 1).layer(src(o0).chroma()).out(o1) render() GLSL Injection # Since Hydra runs GLSL on the background, and everything you input into the parameters of the different functions ends up written on GLSL (be it literally or as a uniform), you can sort of hack Hydra (and totally break it) by sending strings of GLSL expressions as arguments:\nThe reason you can \u0026ldquo;totally break Hydra\u0026rdquo; here is that Hydra works with a modular flow. In order for it to work, when you do coordinate transforms after a bunch of interconnected textures, these transforms must apply to all coordinate references in the shader. If you inject values of the st coordinates in your arguments, Hydra has no way of applying any further transforms to them, therefore breaking the modularity.\nExtensions # Extra shaders # There are some Hydra extensions that load many custom glsl functions, such as:\nextra-shaders-for-hydra hydra-blending-modes Extra Functionality # The hydra-glsl extension allows you to write GLSL directly in your patches. For example:\nglsl(\u0026#39;vec4(sin(((_st.x*54.)+time*2.)*vec3(0.1,0.102,0.101)),1.0)\u0026#39;) .diff(o0) .glslColor(\u0026#39;vec4(c0.brg,1.)\u0026#39;) .glslCoord(\u0026#39;xy*=(1.0/vec2(i0, i0)); return xy\u0026#39;,.25) .glslCombine(\u0026#39;c0-c1\u0026#39;,o1) .glslCombineCoord(\u0026#39;uv+(vec2(c0.r,c0.b)*0.1)\u0026#39;,o1) .out() by geikha\n"},{"id":34,"href":"/hydra-docs-v2/docs/learning/guides/automatic-patches/","title":"Iteration: automatically generate patches","section":"Guides","content":" Using iteration and conditionals to create patches # by geikha\nNote # For this tutorial we\u0026rsquo;ll be assuming you\u0026rsquo;ve already learned by your own means what iteration and conditionals are in a programming context.\nIteration : automatically generate patches # As you may know from regular programming, or other creative coding environments such as p5, iteration helps us repeat some operation(s) many times to achieve a specific goal. Maybe you would like to layer many similar objects but with slightly different values, and you want so many of them that writing each one manually isn\u0026rsquo;t desirable. Maybe you want to have some form of very specific feedbacks, etc. Let\u0026rsquo;s jump straight into some examples.\nfor loops # For loops that generate patches can be used inside or outside functions, but we will be sticking with the latter for convenience.\nThe typical structure of a patch-generating for loop is as follows:\nsomeFunction = (iterations) =\u0026gt; { accumulator = osc(); // first part of the patch, a source for(i=1; i\u0026lt;iterations; i++){ // i is also called a \u0026#34;counter` accumulator.someTransform(i); } return accumulator; } someFunction(5).out() Of course this is just a useful example, and your code may end up looking very different depending on what crazy ideas you want to try. But let\u0026rsquo;s use this as a starting point. See how the use of a function allows us to reuse this iterative process with different parameters such as the amount of iterations. Also note how we start the counter variable i on the value 1 instead of the typical 0. Since 0 will usually null an effect, the result will be equal to the first value assigned our accumulator, so we can skip the 0 iteration altogether. For those not familiar with the abbreviation i++, this basically means i+=1, which means i = i+1.\nExample: rotating # Here we want to see how it would look like if we grab an oscillator of a given freq frequency, and calculate the diff between other rotated oscillators of the same frequency. To achieve that, we define our accumulator nest with the initial value of osc(freq,.02). Then, we define a step which will be how many radians the oscillator will rotate. We calculate this as a division of 2pi (a full 360° turn) by some div number. Then we iterate over nest, applying the diff and the effect respectively, and adding a step to our counter r each iteration.\nExample: very specific feedback # Example: layering varying circles # Try adding or changing the transforms that happen to every nextCircle and see how drastically yet easily they can change the visuals. Specially using transforms like repeatX. Still, always keep in mind while using iteration, that the more effects and iterations you add, the heavier the sketch will be to process.\n.forEach, .map and .reduce # Those familiar with more array focused programming languages such as Python or Haskell, or more functional structures even inside JavaScript, may be used to iterating using the forEach, map and/or reduce structures. Where given an Array, we use each value to alter something or to reduce the entire Array into a desired result. Practically anything done with these functions can be done using for loops, so if you are new to these or you just don\u0026rsquo;t like how they look, then there really is no need for you to learn these, even if you\u0026rsquo;re super interested in iteration.\n.forEach # Structures using .forEach are quite useful for those who\u0026rsquo;d like to generate patches from predefined data. Here\u0026rsquo;s an example using the ASCII values of a given string:\nTry changing the text, and remember not to use very long strings given they will be quite heavy to process.\n.reduce # Using .reduce is quite useful when you have an array of textures. Here\u0026rsquo;s a simple example:\n.map # Haters of state (non-political) will prefer .map any day over .forEach. Looking at the example for .forEach, we see were creating a texture and adding it to an accumulator for each element in the Array. We can separate the texture generating part of the code and the blending part using .map to get an array of textures and .reduce to blend them:\nConditionals # Conditionals aren\u0026rsquo;t very useful on their own here, given all code execution on Hydra happens arbitrarily and manually via the interaction of the user. The only case you would want to use an if statement by its own while livecoding Hydra is that where you\u0026rsquo;d like some variable to change given some condition and only at the time of each code evaluation. But even still, you\u0026rsquo;ll see that putting any conditionals inside functions will be the most useful approach because of code reusability and readability. Let\u0026rsquo;s get to it.\nConditionals in functions # We know from previous tutorials we can make our own functions to be used as arguments of Hydra sources and transforms, and how Hydra evaluates these functions each frame. Here\u0026rsquo;s an example where we use conditionals to have a hue change happen only during 3 seconds out of every 10 seconds:\nAnother common use of conditionals in programming is to avoid errors or undesired behaviors. Here\u0026rsquo;s a simple example where we wrap the square root function from the Math API into our own sqrt function which turns any negative input into positive:\nThe ternary operator # Before we go forward and use both iteration and conditionals, we\u0026rsquo;d like to show you the ternary operator. This operator can simplify many conditional operations. The syntax is the following:\nx = condition ? valueIfTrue : valueIfFalse; // which is the same as if(condition) x = valueIfTrue else x = valueIfFalse Now we can simplify the hue change example into:\nosc(20,.1,2.6) .modulate(osc(20).rotate(Math.PI/2),.3) .hue(()=\u0026gt; time%10\u0026lt;3 ? time/2 : 0) .out() Conditionals inside iterations # Let\u0026rsquo;s go back to a previous example, the nest, where we wanted to do many diff using the same oscillator many times with different angles of rotation. Here\u0026rsquo;s a new version where we invert the colors of the first half of oscillators, and we apply colorama to the oscillator in every other iteration.\nThe first change you\u0026rsquo;ll notice is that now we\u0026rsquo;re calculating the angle of rotation r inside the iteration, and for that we now use a regular counter such as i. We can get the exact same angle of rotation as before via multiplying the counter by the step. We do this specifically because if we want to have something happen every other condition, we\u0026rsquo;ll need to know if the number of iteration we\u0026rsquo;re in is even or not. This is what happens at if(i%2==0). However we still make use of r inside of the first conditional, if(r\u0026lt;Math.PI). This will result in about half of the oscillators to be inverted, given Math.PI is half a turn.\n"},{"id":35,"href":"/hydra-docs-v2/docs/learning/guides/javascript/","title":"javascript for hydra users","section":"Guides","content":" JavaScript Guide # This guide is made for users who are new to JavaScript or coding in general and would like to dive into these topics. You don\u0026rsquo;t need to fully understand what\u0026rsquo;s here to use Hydra. If you\u0026rsquo;re just starting with Hydra and you have no coding experience, we recommend you experiment with Hydra a bit before reading this.\nComments # // This is a one line comment Most programming languages have implemented in them a feature commonly referred as comments. These are ways to write annotations into your code without having the machine interpret them as code. JavaScript, the scripting language that Hydra works on, has implemented comments in the same tradition as many other languages such as Java or C. You use // for single line comments, and you can use /* ... */ for multi-line comments.\n/* An example of a multi line commentary: This sketch shows an oscillator: */ osc().out() You can also write comments at the end of lines of code too, which is very useful while annotating what\u0026rsquo;s going on with your visuals sometimes:\nnoise(2,.5) .diff(src(o0).rotate(Math.PI/4)) // rotating by 45° .thresh(.5) .color(1,.1,.3) // pink color .out() You will surely find useful sometimes to \u0026ldquo;comment in and out\u0026rdquo; some lines of code to see how it affects the visuals, or simply to understand what each line of code does. By adding a // at the start of a line you can comment it out and see how some sketch would look like without a given transform without having to delete the original line.\nnoise(2,.5) .diff(src(o0).rotate(Math.PI/4)) // rotating by 45° //.thresh(.5) .color(1,.1,.3) // pink color .out() Variables # Variables are spaces of memory in your computer that you reserve to store some value. Each variable you use will have a unique symbolic name. This definition may sound complicated, but you\u0026rsquo;ll see it\u0026rsquo;s really as intuitive as it can be. You may remember variables from mathematics being letters that represent some sort of number. This is precisely the same, you just choose some name and assign some number (or other type of information) to it.\nIn the previous example, freq is the name of the variable and 50 is its value.\nVariable names can\u0026rsquo;t start with numbers, they start with letters and it\u0026rsquo;s conventional in JavaScript to start with a lowercase. When the name of your variable is more than one word, it\u0026rsquo;s also conventional to write them as such:\nHowever this is just a convention, you may find other ways of naming your variables more useful. You may even like to use only one letter variables (such as x, y, etc), it\u0026rsquo;s faster to code but harder for others to understand. Find your own balance and style.\nGlobal variables # When you declare a variable in Hydra, it declares it for you on the global scope. You can imagine a scope as a piece of code that works on its own and has its own variables. However, the global scope is basically a bunch of variables and functions that can be accessed from anywhere (functions such as osc() are declared in the global scope so that you can use them by just calling them, no matter where, for example). We can make it explicit that we want something on the global scope. In JavaScript, since it\u0026rsquo;s made to run on a browser, we do this by declaring variables on the window object (what is an object, you can find out below), which represents the browser\u0026rsquo;s window.\nwindow.globalVariable = 21.4 osc(globalVariable).out() However, you can drop the window. part since the default behavior is the same:\nglobalVariable = 21.4 osc(globalVariable).out() If you see JavaScript code elsewhere you\u0026rsquo;ll surely see the keywords let or const. These define variables on their scope. So avoid them if you want to declare variables that can be freely used while livecoding.\nlet scopedVariable = 21.4 // this will only work if evaluated on the same block osc(scopedVariable).out() This knowledge will come in handy if you start coding functions for example, since each function has its own scope, and if you want to declare something on the global scope, you\u0026rsquo;ll have to be explicit about it.\nArrays # Arrays are basically lists of values. Instead of declaring 100 variables to represent different values of the same concept you can just use a list of values. The key thing is these values are related, they will serve the same purpose somewhere in our code. If they are not related, using a list isn\u0026rsquo;t really useful, we\u0026rsquo;ll be just confusing ourselves thinking about where in the list did we put this or that other value. Here\u0026rsquo;s an example of an Array:\nThe example above isn\u0026rsquo;t that useful in a Hydra context, but we hope it illustrates the basics of how an Array is created and used. Arrays in JavaScript (and in most programming languages) start counting their elements from 0 and not from 1. So if you want the first element of the rots Array, you need to call array[0] instead of array[1]! Same goes for every element. If you want the third element call array[2], and so on. Remember that nth element = array[n-1]\nArrays as sequences # Arrays in Hydra can be used as inputs. Hydra takes the list of values and makes a sequence out of them:\nYou can learn more about dynamic inputs here.\nFunctions # A function is similar to a variable in the sense that you\u0026rsquo;re going to give it its own name and call it multiple times later. The difference being that functions do not store values, they store pieces of code that -usually- return some value. You can see them as little boxes where you put something in and they spit something out. Functions will help you not to repeat your code multiple times, sometimes you\u0026rsquo;ll see you can write a function that spits out what you need instead of rewriting it many times.\nDefining functions # There are multiple ways to define functions in JavaScript, here\u0026rsquo;s an example of a function named sum that takes two numbers called a and b and returns (spits out) the sum of both numbers:\nfunction sum(a,b){ return a+b; } sum = function(a,b){ return a+b; } sum = (a,b) =\u0026gt; a+b We\u0026rsquo;ll be sticking with the last form of defining functions, usually called \u0026lsquo;arrow function\u0026rsquo;. It is worth noting the first form it\u0026rsquo;s a bit like using let and const for variables, they work on their own scope.\nLocal variables in functions # Talking about scope, you may want to define variables inside your functions, which are local to the functions and aren\u0026rsquo;t variables that should be used globally. Now the let keyword becomes useful.\nsum = function(a,b){ let result = a+b; return result; } sum = (a,b) =\u0026gt; a+b Functions that return a texture # Now you may be thinking \u0026ldquo;Wait, shouldn\u0026rsquo;t this simply be a variable that stores that texture? If there\u0026rsquo;s no input what\u0026rsquo;s the use of having a function here?\u0026rdquo;. And in a way you would totally be right. Except for the fact that if you use a variable to store that shape, you\u0026rsquo;ll be always referring to the exact same object that represents that shape. If you use a variable circle and apply some transforms to it somewhere in your patch, and try to use circle again later, all the transforms that you applied will be there! Because you applied those to that object precisely. Also, even if you don\u0026rsquo;t apply any transforms, JavaScript can be very messy when referencing the same object multiple times in some situations. So, if you use a function, each time you call it a new object representing that texture will be created. Another reason we would use a function in this example is that if we want to add some input to this function, well, it\u0026rsquo;s already a function so we can do it.\nLet\u0026rsquo;s see how we could make the circle function more useful by adding parameters:\nNow, each time we call the circle function we can specify a size and blur. We can also omit the blur and the function will use the default value specified next to it. We also changed the scaling to an arrow function, which you may find surprising if you haven\u0026rsquo;t seen it before. When you use a function as an argument, Hydra will evaluate that function every time it renders a frame and use the return of that function in the rendering of that frame. In other words, functions can be used as dynamic inputs.\nUsing declared functions as inputs # As we just mentioned, we can use arrow functions inside the arguments of a given source or transform for it to react in real time. If you have many arguments using the same arrow function, you may want to declare it and reuse its name:\nCalling declared functions from other functions # Sometimes you want to reuse a function but have something change about it. For example, maybe we want to make the scaling negative for the feedback in the last example. But calling -scaling doesn\u0026rsquo;t make sense, at least to JavaScript, since the negative of a function doesn\u0026rsquo;t exist. But the negative of its return does:\nNote on functions with parameters # You\u0026rsquo;ll also come across this if your function has parameters. For example:\nscaling = (multiplier)=\u0026gt; (.9+(Math.sin(time*2)/3))*multiplier Doing .scale(scaling) doesn\u0026rsquo;t make sense anymore, since you aren\u0026rsquo;t giving it its necessary input. And if you try to do .scale(scaling(-1)), Hydra will evaluate the function once and use its return as the input to scale, instead of using a function which is what we want for the visual to react to the changes in time. The solution is, again, a function that calls your function, such as .scale(()=\u0026gt;scaling(-1)). If for some reason you hate arrow functions, you could also try binding it doing .scale(scaling.bind(0,1)).\nHigher-order functions # Higher order functions just means functions that take other functions as arguments. These are useful when you want to make u new functions which take behavior from other functions. As an example, let\u0026rsquo;s visualize applying a sine function (with some tweaks) to itself:\nThat new ...args thing simply takes all the arguments sent to a function, we use it so we can call whatever function sent with as many arguments as it needs. Take into account twice(myFunc,time) is the same as myFunc(myFunc(time)), and you may prefer to write the latter in many occasions. But you can also send an arrow function to twice, which could save you declaring a functions you may only want to use once, or writing the same declaration twice.\nObjects # You can imagine an object as a special variable, which instead of containing a value, it contains other variables and functions. The former are usually called properties of an object and the latter are methods of an object. For example, if you ever use Hydra on instance mode, what you\u0026rsquo;ll come across is Hydra as a special object containing all the functions you know and love, instead of having them on the global scope.\nLet\u0026rsquo;s see an example of how to declare and use an object with some properties:\nAnd now let\u0026rsquo;s add a method:\nThere\u0026rsquo;s a new keyword that we hadn\u0026rsquo;t seen before here: this. The this keyword is used in methods (functions of an object) to refer to the object from which the method is called.\nObjects can also be conceptualized as dictionaries, with keys and values. The keys would be the names of the properties (and methods) of the object and the values is what they store:\nnumbers = { pi: 3.14159265359, e: 2.71828182846, golden: 1.61803398875 } numbers[\u0026#39;pi\u0026#39;] // another way we can call keys from an object Useful properties in the window object # The window object has lots of information about the environment that our visuals run on. You\u0026rsquo;ll see lots of Hydra sketches that make use of them, more commonly for example, the innerWidth and innerHeight properties. These properties store the respective width and height that the webpage occupies on your screen.\nFor example, we can calculate the ratio between height and width to have perfect squares on our sketches:\n// this example will only work on the editor or atom-hydra screenRatio = innerHeight/innerWidth shape(4,.4).scale(1,screenRatio) .out() There\u0026rsquo;s also the less used screenX and screenY which will tell you the position of the window relative to the full screen. Try to move your browser\u0026rsquo;s window with the following example:\nThe Math Object # You have surely seen many examples in Hydra and in these tutorials that make use of mathematical functions such as the sine wave. You may have also noticed that each time one of them is used, they\u0026rsquo;re written as Math.somefunction(). The reason for this is that all these very useful functions are taken from a special object called Math that is present in practically every JavaScript implementation. You can see the full list of functions and variables in the Math object clicking here.\nMath.PI # One of the most useful predefined variables that the Math API has is the value of pi (well, an approximation considering that pi has infinite decimals). Many Hydra functions take radians as arguments which you may know are usually represented using multiples of pi. For example, if you want to rotate a texture exactly half a pi (90 degrees), you can do it as such:\nby geikha\n"},{"id":36,"href":"/hydra-docs-v2/docs/learning/guides/how-to/record-hydra-output/","title":"Record hydra's output","section":"How to","content":" Recording # Saving images from Hydra # You can press Ctrl+Shift+S to save a screenshot of your Hydra\u0026rsquo;s canvas, as well as the code that generates the screenshot. You can also do this programmatically calling the function screencap()\nHydra\u0026rsquo;s built-in recorder # You can very easily record a video evaluating the following commands:\nvidRecorder.start() // run this to start recording vidRecorder.stop() // run this to stop recording and download video Videos recorded with this method are recorded and downloaded with the vp9 codec and webm filetype. However, they can also be quite low quality.\nOBS # OBS is the preferred recording method by most Hydra users. It\u0026rsquo;s a free and open source software for video recording and live streaming available on practically all platforms.\nHow to use OBS # Download and open OBS In the Controls pane on the right side, click on Settings Go to the Output tab, then to the Recording pane and set your preferences. Then click on OK. On the Sources pane, click on the + icon and select Window Capture. If you want to, give the new source a name and click OK Set the Window to the browser your running Hydra on. Most users also prefer to unselect the Capture cursor setting. Click OK. On the preview at the middle of the screen, select your source, right click and then click on Resize output (source size), select Yes. Set your audio input\u0026rsquo;s volume (or mute it) on the Audio Mixer pane. On the Controls pane, click Start Recording. When you want to stop, click Stop Recording. Trim the browser\u0026rsquo;s UI # If you don\u0026rsquo;t want to record your browser\u0026rsquo;s UI, do the following:\nRight click your source and click on Filters. Click on the + icon on the lower left corner and select Crop/Pad. Click OK. Set the values until your UI disappears. Sometimes you only need to set the Top value. Click OK Note on window size # If you want to set your browser\u0026rsquo;s window to a specific size, there are various add-ons on different browsers that allow you to do that. Remember you want to set the size of the view pane and not the whole window.\nby geikha\n"},{"id":37,"href":"/hydra-docs-v2/docs/learning/guides/how-to/use-hydra-without-showing-code/","title":"Use hydra without showing the code","section":"How to","content":" How can I livecode Hydra without showing the code over the visuals? # You can either:\nUse Flok: # Open https://flok.cc/ and create a session with hydra as a target. Now that you have your own Hydra session, with its own URL (it automatically changes on your browser\u0026rsquo;s nav bar), open it in one more tab. Enter the session in both tabs. You can disable Hydra on one of them if you want to (this would also lower resource demand). On one of your tabs, press \u0026ldquo;Ctrl+Shift+H\u0026rdquo; to hide the code. Now you can code on one tab and commands will also run on the other tab!\nUse your browser\u0026rsquo;s dev tools console: # Here\u0026rsquo;s a tutorial by Flor de Fuego about how to do this: [EN] [ES] "},{"id":38,"href":"/hydra-docs-v2/docs/learning/extending-hydra/extending-hydra/","title":"Using hydra with other javascript libraries","section":"Extending Hydra","content":" Using hydra with other javascript libraries # Hydra is written in javascript, and compatible with many other javascript libraries. The hydra web editor executes javascript directly in the browser, so it is possible to load many other libraries and scripts directly in the browser.\np5.js # p5.js is a JavaScript library for creative coding, with a focus on making coding accessible and inclusive for artists, designers, educators, beginners, and anyone else! p5.js is pre-loaded on the Hydra editor with a wrapper that makes it easier to use inside the website. The wrapper is a class called P5 (notice the upper-case P). A p5.js sketch can be used as a source within a hydra sketch, and vice versa.\np5 + hydra example # // Initialize a new p5 instance It is only necessary to call this once p5 = new P5() // {width: window.innerWidth, height:window.innerHeight, mode: \u0026#39;P2D\u0026#39;} // draw a rectangle at point 300, 100 p5.rect(300, 100, 100, 100) // Note that P5 runs in instance mode, so all functions need to start with the variable where P5 was initialized (in this case p5) // reference for P5: https://P5js.org/reference/ // explanation of instance mode: https://github.com/processing/P5.js/wiki/Global-and-instance-mode // When live coding, the \u0026#34;setup()\u0026#34; function of P5.js has basically no use; anything that you would have called in setup you can just call outside of any function. p5.clear() for(var i = 0; i \u0026lt; 100; i++){ p5.fill(i*10, i%30, 255) p5.rect(i*20, 200, 10,200) } // To live code animations, you can redefine the draw function of P5 as follows: // (a rectangle that follows the mouse) p5.draw = () =\u0026gt; { p5.fill(p5.mouseX/5, p5.mouseY/5, 255, 100) p5.rect(p5.mouseX, p5.mouseY, 30, 150) } // To use P5 as an input to hydra, simply use the canvas as a source: s0.init({src: p5.canvas}) // Then render the canvas src(s0).repeat().out() breakdown of p5.js functions in hydra # p1 = new P5() // first, load p5 in instance mode You can also specify some settings:\np1 = new P5({width: 512, height: 512, mode: \u0026#39;P2D\u0026#39;}) Now the p5 canvas is overlaying the Hydra canvas. You can hide it by running:\np1.hide() // p1.show() to revert And you may load it to a source to use p5\u0026rsquo;s canvas as one:\ns0.init({src: p1.canvas}) p5.setup() # When live coding, the setup() function of p5 has basically no use; anything that you would have called in setup() you can simply call outside of any function. For example:\np1.noStroke() p1.fill(255, 0, 100) p5.draw() # Now, to set a draw loop simply use all the functions and variables you are used to on global p5 from the variable you\u0026rsquo;re using:\np1.draw = () =\u0026gt; { p1.fill(p1.mouseX/5, p1.mouseY/5, 255, 100) p1.rect(p1.mouseX, p1.mouseY, 30, 30) } Livecoding # You can technically call any p5 function while livecoding. So you can draw anything onto screen on evaluation instead of using the draw loop.\np1.clear() for(let i = 0; i \u0026lt; 50; i++) p1.rect(20, 20, p1.width/50*i, p1.height/50*i) Using Hydra\u0026rsquo;s render loop # You can stop p5\u0026rsquo;s own looping and do your p5 actions inside Hydra\u0026rsquo;s render loop via the update function. This will synchronize p5\u0026rsquo;s and Hydra\u0026rsquo;s frame renders.\np1.noLoop(); p1.clear() p1.colorMode(p1.HSB) p1.stroke(0) p1.strokeWeight(1) src(o0) .scale(1.05) .blend(src(o0).brightness(-.02),.4) .modulateHue(o0,100) .layer(s0) .out() p1.draw = () =\u0026gt; { if(p1.random() \u0026lt; 0.01) p1.clear() p1.fill(time*100%200, 70, 100) p1.rect(p1.random()*p1.width, p1.abs(p1.sin(time*2))*p1.height, 50, 50) } update = (dt)=\u0026gt; { p1.redraw(); } You could also use shape drawing functions such as rect directly inside update, but you\u0026rsquo;ll need to take into account the coordinate system won\u0026rsquo;t be reset automatically if modified, like when using draw. So you\u0026rsquo;ll have to reset it manually by putting actions between push() and pop(). This would also stop the frameCount increment.\nNote on using different frame rates # There are many situations where you can save resources by using a very low frame rate on p5 and a high one on Hydra or vice-versa. For example, if you want to place random shapes on the p5 canvas every second, you can set p5\u0026rsquo;s frameRate to 1 and leave Hydra\u0026rsquo;s fps undefined.\nTO DO: add example of using hydra as texture in p5\nLoading external scripts # The await loadScript() function lets you load other packaged javascript libraries within the hydra editor. Any javascript code can run in the hydra editor.\nTHREE.js # Here is an example using Three.js from the web editor:\nawait loadScript(\u0026#34;https://threejs.org/build/three.js\u0026#34;) scene = new THREE.Scene() camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000) renderer = new THREE.WebGLRenderer() renderer.setSize(width, height) geometry = new THREE.BoxGeometry() material = new THREE.MeshBasicMaterial({color: 0x00ff00}) cube = new THREE.Mesh(geometry, material); scene.add(cube) camera.position.z = 1.5 // \u0026#39;update\u0026#39; is a reserved function that will be run every time the main hydra rendering context is updated update = () =\u0026gt; { cube.rotation.x += 0.01; cube.rotation.y += 0.01; renderer.render( scene, camera ); } s0.init({ src: renderer.domElement }) src(s0).repeat().out() Tone.js # And here is an example loading the Tone.js library:\nawait loadScript(\u0026#34;https://unpkg.com/tone\u0026#34;) synth = new Tone.Synth().toDestination(); synth.triggerAttackRelease(\u0026#34;C4\u0026#34;, \u0026#34;8n\u0026#34;); Custom libraries # In the Hydra editor, you can load any external scripts, libraries or hydra-synth extensions using the following syntax at the top of your sketch:\nawait loadScript(\u0026#34;https://www.somewebsite.com/url/to/hydra-script.js\u0026#34;) You can also suffer from CORS policy problems if the script/package you\u0026rsquo;re loading doesn\u0026rsquo;t come from a CDN. If you want to load from a GitHub or GitLab repo, you can use special CDNs like statically.io.\ncontributors: geikha, olivia\n"}]